1、css选择器以及优先级
!important >行内样式>id>class>tag>继承
2、闭包，closure
函数和对其周围环境状态的引用捆绑在一起 构成闭包
让你能够在内部函数内部访问外部函数作用域
保存了对外部作用域的引用

3、继承
原型链继承
  Child.prototype=new Parent();
  引用类型的属性被所有实例共享
  不能向构造器传参
构造函数继承
  function child(){
    Parent.call(this,arguments);
  }
  引用类型不再被所有实例共享
  可以向构造器传参
  每次创建实例都会执行一遍方法
组合继承
  构造器+原型链
  function child(){
    Parent.call(this,argument);
  }
  child.prototype=new Parent();
  child.prototype.constructor=child;



4、js基本数据类型
5、js放在body前面的原因，就是放在正文最后的原因
6、请求头有哪些
7、从url到页面展示需要经过的哪些步骤
  浏览器进程：
    浏览器进程、渲染进程、GPU进程、网络进程、插件进程
     ![avatar](/assets/webwork.webp)
  1，用户输入
    1，判断地址栏输入的关键字类别，内容是不是url
      - 如果是搜索内容，使用浏览器默认的搜索引擎
      - 如果是url的话，把这个加上协议，生成完整的url
      - 进入加载状态
  ![avatar](/assets/webwork.webp) 
  2，URL请求
    1，网络进程会查找本地缓存中是否缓存了该资源
      - 有，直接返回资源给浏览器进程
      - 无，进入网络请求流程
    2, DNS解析
      - 目的：获取请求域名的服务器IP地址
      - 过程：
        - DNS缓存中查找
          - 有，直接返回
          - 无
            - 先查找本地的hosts文件是否有这个网址的映射
              - 有，返回ip地址的映射
              - 无
                - 查找DNS解析器的缓存，有直接返回
                  - 无，请求到达本地的DNS服务器，本地DNS服务器有缓存话返
                    - 无，如果缓存了映射关系，调用这个IP的映射，完成解析
                      - 无，进行迭代的查询，最终获得结果
      - 使用的是UDP数据，53端口
    3, 利用IP地址和服务器建立TCP连接 
      - 三次握手
    4, 发送请求 
      - 把请求的东西加到请求头上去，向服务器发送构建的请求
    5, 服务器接收到亲请求后，生成响应数据，发送给网络进程
    6, 网络进程拿到数据之后进行解析
      - 重定向 通过状态码判断
      - 响应数据类型处理
        - text/html 浏览器会继续进行
        - 下载类型 提交给浏览器的下载管理器，结束
    7，准备渲染进程，同源的会使用同一个，正常情况下会新开一个
    8，网络进程将数据提交给渲染进程，渲染进程接收到了之后，就会对信息进行处理
    9，构建dom树
    10，构建cssom树，
    11，dom树和cssom树结合生成渲染树
    12，计算出dom在页面上的位置和大小，生成布局树
    13，为特定的节点生成专用的图层，生成对应的图层树
    14，把一个图层的绘制拆分成很多小的绘制指令，把指令按顺序生成绘制列表，提交给合成线程
    15，视口区域不大，如果页面太大的话，为了提高性能合成进程会将图层进行分块。
    16，栅格化，

8、盒子模型
9、TCP要慢一些的原因（从三次握手、流量控制、拥塞控制回答）
10、DNS解析以及使用的是TCP还是UDP协议

行内元素和块级元素的区别
如何使得行内元素的宽高有效
css盒模型
BFC
触发BFC的条件
水平垂直居中的方式
css选择器的权重
less，sass
leass，sass的优势
闭包
过多使用闭包，会有什么问题
跨域了解多少
介绍一下jsonp
同源策略
  指“协议+域名+端口”三者相同（不同文件路径可以）
  导致cookie、localstorage和indexdb无法读取
  dom和js对象无法获得
  ajax请求无法发送

  jsonp
    原理利用<script>标签没有跨域的限制，通过script标签的src属性，发送带有callback参数的get请求，后端将返回数据拼凑到callback中，返回给浏览器，浏览器解析，从而得到数据
    ``` javascript
    script = document.createElement('script');
    script.type = 'text/javascript';
    // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
    script.src = 'http://www.domain2.com:8080/login?user=admin&callback=handleCallback';
    document.head.appendChild(script);
    // 回调执行函数
    function handleCallback(res) {
        alert(JSON.stringify(res));
    }
    ```
  跨域资源共享cors
    允许浏览器向跨源服务器
      服务器设置ACCESS-CONTROL-ALLOW-ORIGIN响应头，设指定来源
      进行两次请求
    简单跨域请求
      1，get，post，head等http方法之一
      2，http的头信息不超过
        accept
        accept-language
        content-language
        last-event-id
        content-type只限于application/x-www-form-urlencoded、multiple/formdata、text/plain
      响应头：
        Access-Control-Allow-Origin：数据的可见范围
    复杂请求
      1，任何一个不满足的简单跨域要求的请求都是复杂，带预检的跨域请求。
      一个复杂请求不止发送一个包含通信内容的请求，其中最先发送的是一种**"预检"请求**，此时作为服务端，也需要返回**"预回应"**作为响应。"预检"请求实际上是对服务端的一种权限请求，只有当"预检"请求成功返回，实际请求才开始执行。
      预请求以OPTIONS形式发送，当中同样包含域，并且还包含了两项CORS特有的内容
      Access-Control-Request-Method – 该项内容是实际请求的种类，可以是GET、POST之类的简单请求，也可以是PUT、DELETE等等。
      Access-Control-Request-Headers – 该项是一个以逗号分隔的列表，当中是复杂请求所使用的头部。
      "预检"请求实际上就是在为之后的实际请求发送一个权限请求，在预回应返回的内容当中，服务端应当对这两项进行回复，以让浏览器确定请求是否能够成功完成。一旦预回应如期而至，所请求的权限也都已满足，才会发出真实请求，携带真实数据
      预请求响应数据:access-control-allow-method:支持的方法，access-control-allow-headers：支持的头部信息
      后台设置Access-Control-Max-Age来控制浏览器在多长时间内（单位s）无需在请求时发送预检请求，从而减少不必要的预检请求
  nginx代理
    通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段
  node中间件跨域
    启一个代理服务器实现数据的转发
  postmessage跨域
    页面和其打开的新窗口的数据传递
    多窗口之间消息传递
    页面与嵌套的iframe消息传递

js继承
http常用状态码


302什么含义？


304



cookie和localStorage、sessionStorage生命周期及作用域



.标准盒模型与怪异盒模型；
2.box-sizing（说错了，面试官让我回去了解下）
3.url输入后到页面显示；
4.垂直居中实现；问到align-items给父元素设置还是给子元素设置；犹豫不决，让选一个，最后选了父元素，对了
5.get与post区别；
6.实现函数，返回Promise状态为resolve（用两种方法）；
7.算法:数组降维（实现float，递归，不能用mapfloat）
8.实现三列等宽布局；（答用bootstrap栅格布局实现，问能否用flex实现，不会。 问了解grid布局不，说没用过，就没再问）
9.写代码，判断this指向问题；
10.箭头函数与普通函数区别
11.手写new的过程；
12.写代码让判断资源加载顺序，js加载的时候会阻塞页面渲染吗?(答得 会；)  js应该放到什么位置合适；说到了defer与async，问二者的区别（说的不清）
13.同源策略
14.js中数据类型（基本、引用）判断类型时分别用什么方法